---
title: "The Gibbs Sampler, R Code"
output:
  html_document:
    code_folding: hide
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.align = "center")
library(ggplot2)
library(dplyr)
library(kableExtra)
library(rjags)

runFresh = FALSE
if (!runFresh) load("GibbsCode.rda")
```

## Base R Code

```{r, eval = runFresh}
set.seed(123)
real_thetas <- c(0.2, 0.6)
N <- 300
a = 2
b = 3
change_point <- 100
x <- c(rbinom(1:change_point, 1, real_thetas[1]),rbinom((change_point+1):N, 1, real_thetas[2]))


## Initialize all parameters

# n ~ uniform 
n <- round(N*runif(1))
# theta1 ~ beta(a,b)
theta1 <- rbeta(1, a, b)
# theta2 ~ beta(a,b)
theta2 <- rbeta(1, a, b)



niters = 3000
burnin = 1000

params = matrix(0, nrow = (niters-burnin), ncol=3)
for (i in 1:niters){
  
  
  z1 <- sum(x[1:n])
  if(n == N){
    z2 <- 0
  }else{
    z2 <- sum(x[(n+1):N])
  }
  theta1 = rbeta(n = 1, shape1 = a + z1, shape2 = b + n - z1)
  # get value theta2| all other vars
  theta2 = rbeta(n = 1, shape1 = a + z2, shape2 =N-n-1-z2+b)
  
  
  ## 2 things: 1 - should I be summing all the values over these? 
  # No - the product is being calculated due to the sum - should be fine
  n_multi <- rep(0, N)
  for(steps in 2:N){
    if(steps==N || theta2 == 1){
      n_multi[steps] <- log(theta1^sum(x[1:steps]) * (1-theta1)^(steps-sum(x[1:steps])))
    }else{
      n_multi[steps] <- log(theta1^sum(x[1:steps]) * (1-theta1)^(steps-sum(x[1:steps]))) +
        log(theta2^sum(x[(steps + 1):N]) * (1-theta2)^(N-steps-1-sum(x[(steps+1):N])))
    }
  }
  
  n_multi <- exp(n_multi[2:N] - max(n_multi[2:N]))
  # offset by 1 
  # you n is equally probably between 2 and N and zero at n=1
  # we only calculate p(n) from n=2 to N
  n <- which(rmultinom(1, 1, n_multi/sum(n_multi))[,1] ==1) + 1
  if (i >= burnin){
    params[(i-burnin), ] = c(theta1,theta2, n)
  }
}

ds <- data.frame(x = x, theta = c(rep(real_thetas[1],N-change_point),
                                  rep(real_thetas[2],change_point)), 
                 sample_index = seq(1:length(x)))

params_df <- as.data.frame(params)
names(params_df) <- c('theta1', 'theta2', 'change_point')

ggplot(params_df, aes(x = change_point)) + 
  geom_histogram(fill="#7A99AC", color ='#1A384A', binwidth = 5, bins = floor(N/5)) +
  theme_minimal() + 
  scale_x_continuous(limits = c(0,N)) +
  geom_vline(xintercept = mean(params_df$change_point), color='#b7091a') +
  labs(title = 'Change Point Estimate', x='Change Point', y = 'Density') 


```

```{r}
ggplot(params_df, aes(x = theta1)) + 
  geom_histogram(fill="#7A99AC", color ='#1A384A' , binwidth = 0.025) + 
  theme_minimal() + 
  scale_x_continuous(limits = c(0,1)) +
  geom_vline(xintercept = mean(params_df$theta1), color='#b7091a') +
  labs(title = expression(theta[1]~Estimate), x=expression(theta[1]), y = 'Density') 
```

```{r}
ggplot(params_df, aes(x = theta2)) + 
  geom_histogram(fill="#7A99AC", color ='#1A384A' , binwidth = 0.025) + 
  theme_minimal() + 
  scale_x_continuous(limits = c(0,1)) +
  geom_vline(xintercept = mean(params_df$theta2), color='#b7091a') +
  labs(title = expression(theta[2]~Estimate), x=expression(theta[2]), y = 'Density') 
```


The resulting estimates for each of our parameters is shown below along with the real value used to generate the dataset.


```{r, results='asis'}

data.frame(theta_1 = c(real_thetas[1], mean(params_df$theta1)),
       theta_2 = c(real_thetas[2], mean(params_df$theta2)),
       n = c(change_point, floor(mean(params_df$change_point))),
       row.names = c('True', 'Estimated')) %>% 
  knitr::kable(col.names = c('\u03b8\u2081', '\u03b8\u2082', 'n'),
        digits = 2,
        row.names = TRUE, 
        caption = 'Change Point Parameters and Estimates') %>% kable_styling(bootstrap_options = "striped", full_width = F)
```



## RJAGS

### Mixture of Normal Distributions

I show a simple illustration of a mixture of normal distributions. For the examples, we assume we have metric values that we suppose are generated by a mixture of two different normal distributions, which I'll call clusters. We don't know which datum came from each cluster. Our goal is to estimate the probability that each score came from each of the two clusters, and the means and SD of the normal distributions that describe the clusters.

```{r}
# DEFINE the model
#The model specification (for JAGS): The assumes that the clusters have the same standard deviation, but different means.

mix_model <- "model {
    # Likelihood:
    for( i in 1 : N ) {
      y[i] ~ dnorm( mu[i] , tau )
      mu[i] <- muOfClust[ clust[i] ]
      clust[i] ~ dcat( pClust[1:Nclust] )
    }
    # Prior:
    tau ~ dgamma( 0.01 , 0.01 )
    for ( clustIdx in 1: Nclust ) {
      muOfClust[clustIdx] ~ dnorm( 0 , 1.0E-10 )
    }
    pClust[1:Nclust] ~ ddirch( onesRepNclust )
}"

```


The data specification:


```{r}

# Generate random data from known parameter values:
set.seed(47405)
trueM1 = 100
N1 = 200
trueM2 = 145 # 145 for first example below; 130 for second example
N2 = 200
trueSD = 15
effsz = abs( trueM2 - trueM1 ) / trueSD
y1 = rnorm( N1 )
y1 = (y1-mean(y1))/sd(y1) * trueSD + trueM1
y2 = rnorm( N2 )
y2 = (y2-mean(y2))/sd(y2) * trueSD + trueM2
y = c( y1 , y2 )
N = length(y)

# Must have at least one data point with fixed assignment 
# to each cluster, otherwise some clusters will end up empty:
Nclust = 2
clust = rep(NA,N) 
clust[which.min(y)]=1 # smallest value assigned to cluster 1
clust[which.max(y)]=2 # highest value assigned to cluster 2 
dataList = list(
    y = y ,
    N = N ,
    Nclust = Nclust ,
    clust = clust ,
    onesRepNclust = rep(1,Nclust)
)
```

Run model in RJAGS

```{r, eval = runFresh}
mix_jags <- jags.model(textConnection(mix_model), 
    data = dataList,
    inits = list(.RNG.name = "base::Wichmann-Hill", .RNG.seed = 100))

# SIMULATE the posterior
mix_sim <- coda.samples(model = mix_jags, variable.names = c("muOfClust"), n.iter = 5000)

# PLOT the posterior
#plot(mix_sim, trace = FALSE)#, xlim = c(0,1), ylim = c(0,18))

y = cbind.data.frame(mu = c(mix_sim[[1]]), clust=rep(c("1","2"), each=nrow(mix_sim[[1]])))
  
```

```{r}
g = ggplot(y, aes(mu, fill=clust)) + geom_density(alpha=.5) + ggtitle(paste0("mu1=",trueM1, ", mu2=",trueM2)) 
  #g = g + theme(legend.position = "none")
  g
```


```{r}
save.image("GibbsCode.rda")
```

